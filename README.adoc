= Node.js + Express.js + Sequelize + SQLite/PostgreSQL + React Example Realworld App

Includes a working single-process fullstack <<heroku-deployment>> by building the https://github.com/gothinkster/react-redux-realworld-example-app frontend statically and serving it from the public folder of the backend.

CSS bundling to use https://demo.productionready.io/main.css from the SCSS source is also setup, but blocked on: https://github.com/gothinkster/conduit-bootstrap-template/issues/5#issuecomment-829104220

This started as a fork of: https://github.com/sigoden/node-express-realworld-example-app which was likely a port of https://github.com/gothinkster/node-express-realworld-example-app both of which are backend implementations of the awesome https://github.com/gothinkster/realworld

The `react-redux-realworld-example-app` is stored at link:react-redux-realworld-example-app[] as a submodule, and some small modifications have been made to it from the upstream, they are tracked at: https://github.com/cirosantilli/react-redux-realworld-example-app

Website behaviour is intended to match the front and backend upstreams as closely as possible, minus except possible obvious bugs.

== Local development with SQLite

.....
npm install
npm run dev
.....

The browser automatically pops the development front-end server at http://localhost:4101[] which makes requests to the backend server that runs at http://localhost:3000[].

== Local optimized frontend

.....
npm install
npm run build
npm start
.....

The website can now be seen at: http://localhost:3000

This setup does not start the front-end development server at http://localhost:4101[], but rather compiles the front-end files statically, and serves them on the public folder of the backend server, giving performance representative performance characteristics of the frontend.

This setup is much closer to the final type of setup that will run in production, and it runs a single server.

Running it locally might help debug some front-end deployment issues.

But otherwise you will just normally use the <<local-run-as-identical-to-deployment-as-possible>> setup instead for development, because this setup lacks important debug features such as:

* hot code reloading

This setup still runs on `NODE_ENV=development`, which implies that sqlite is used, so no further database setup is needed for PostgreSQL. This also means however that you might experience different performance characteristics or behaviour not ironed out by Sequelize between SQLite vs PotsgreSQL.

=== Local run as identical to deployment as possible

Here we use PostgreSQL instead of SQLite with the prebuilt static frontend.

For when you really need to debug some deployment stuff locally

Setup:

....
createdb node_express_sequelize_realworld
psql -c "CREATE ROLE node_express_sequelize_realworld_user with login password 'a'"
psql -c 'GRANT ALL PRIVILEGES ON DATABASE node_express_sequelize_realworld TO node_express_sequelize_realworld_user'
echo "SECRET=$(tr -dc A-Za-z0-9 </dev/urandom | head -c 256)" >> .env
npm run build
....

Run:

....
env $(cat .env | xargs) \
NODE_ENV=production \
DATABASE_URL='postgres://node_express_sequelize_realworld_user:a@localhost:5432/node_express_sequelize_realworld' \
npm start
....

then visit the running website at: http://localhost:3000/

== Heroku deployment

Got it running perfectly at as of April 2021 https://cirosantilli-realworld-express.herokuapp.com/ with the following steps:

....
# Automatically sets DATABASE_URL.
heroku addons:create heroku-postgresql:hobby-dev
# Otherwise the react build picks up the .eslint from this directory,
# which specifies a plugin that is not installed because it is in the
# devDependencies of this package.json... For the love of God, this is
# a deployment, not a CI.
# https://stackoverflow.com/questions/55821078/disable-eslint-that-create-react-app-provides
heroku config:set DISABLE_ESLINT_PLUGIN=true
# Notably to skip ultra-slow sqlite native build.
heroku config:set NPM_CONFIG_PRODUCTION=true YARN_PRODUCTION=true
heroku config:set SECRET="$(tr -dc A-Za-z0-9 </dev/urandom | head -c 256)"
git push heroku master
....

== Testing

=== API tests

These tests are part of https://github.com/gothinkster/realworld which we track here as a submodule.

They test the JSON REST API without the frontend:

....
npm run back
npm run test-api
....

That method uses Postman, but we feel that it is not a very good way to do the testing, as it uses JSON formats everywhere with embedded JavaScript, presumably to be edited in some dedicated editor like Jupyter does. It would be much better to just have a pure JavaScript setup instead.

== Benchmarks

Methodology: time after click event https://stackoverflow.com/questions/67750849/how-to-filter-by-event-type-in-chrome-devtools-profile-tab-e-g-to-see-mouse-cli/67750850#67750850 up until new page renders, not considering any images on the new page, just text. All benchmarks on Lenovo ThinkPad P51.

* click from global feed to article
** this repo at 98e628a76b4253bb51ff4a8659305fabfda1b1f8, Chromium 91, `npm run dev`: 0.2s
** this repo at 98e628a76b4253bb51ff4a8659305fabfda1b1f8, Chromium 91, `npm run start`: 0.4s
